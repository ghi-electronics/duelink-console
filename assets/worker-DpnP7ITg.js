!function(){"use strict";importScripts("../consumer-queue.min.js");const e=new TextDecoder,t=new TextEncoder;let a=!1,n=!1,s=!0,o=">",i="",r=null,l=!0,c=null,u=null,d=!0,g="",w=null;const p=new ConsumerQueue,f=[">","$","&"],v=7071;async function m(){try{await async function(){l=!1,c&&(await u.cancel(),await c,c=null)}(),w&&await w.releaseLock(),u&&await u.releaseLock(),await r.close(),P("Port disconnected.")}catch(e){P("There was an error while disconnecting."),k(e?.message||"Unknown error.")}finally{n=!1,postMessage({event:"disconnected"}),postMessage({event:"version",value:null})}}async function b(){a=!0;const e=await x("mem()");postMessage({event:"memoryRegionsResult",result:e}),a=!1}function h(){return new Promise(async e=>{const t=[];let a;do{a=await p.tryPop(),a?(t.push(a),M("flushed - push line:",a)):M("flushed: No line")}while(a);t.length||(g=""),M("flushed",t),e(t)})}async function y(){const e=await x("version()");for(const t of e){if(M("line",t,(t.match(/\./g)||[]).length),-1!=t.indexOf("GHI Electronics DUELink v")){return t.split(":")[0].substring(24)}}}function M(){}function k(e){postMessage({event:"logError",message:e})}function P(e){postMessage({event:"logEvent",message:e})}function _(e=null){return e||(e=o),new Promise(async t=>{const a=[];let n;do{if(n=await p.pop().catch(()=>{t(a)}),!n)break;if(a.push(n),n.startsWith("!")){M("Error:",n);break}}while(n!==e);a.length>1?a.pop():a?.[0]===e&&a.shift(),t(a)})}function E(e){return new Promise(t=>setTimeout(t,e))}async function I(e){let a=t.encode(e),n=a.length,s=0;for(;n>0;){const e=a.subarray(s,s+Math.min(10,n));await w.write(e);const t=await p.tryPop();if(t)return t;s+=10,n-=e.length,await E(1)}return null}async function x(e,a=null,n="\n"){try{postMessage({event:"isTalking",value:!0}),await h(),w.write(t.encode(e+n)),">"!==e&&"$"!==e||(o=e),await E(50);const s=await _(a||o);return s}finally{postMessage({event:"isTalking",value:!1,lastCommand:e})}}addEventListener("message",R=>{switch(M(`---- on "message", do task: ${R.data.task} ----`),R.data.task){case"clearOutput":i="";break;case"connect":!async function(){M(`Port status ${n}`),[r]=await navigator.serial.getPorts();try{await r.open({baudRate:115200,dataBits:8,parity:"none",stopBits:1,flowControl:"none"})}catch(d){return postMessage({event:"ConnectFailed",message:d?.message,name:d.name,full:d}),void k(d?.message||"Unable to open port.")}if(r.addEventListener("disconnect",()=>{M("Port disconnected"),m()}),null==r?.writable)return void k("Port is not a writable.");if(null==r?.readable)return void k("Port is not a readable.");if(w=r.writable.getWriter(),u=r.readable.getReader(),function(){c=async function(){let t,s=!0;l=!0;for(;l;)try{const{value:o,done:r}=await u.read();M("Reading... Done?",r);const c=e.decode(o).replace(/\r/gm,"");if(n&&!f.includes(c.substring(-1,1))){if(i+=c,i.length>2e3)if(c.length<i.length){i=i.substring(c.length,i.length);const e=i.indexOf("\n");e>-1&&(i=i.substring(e+1,i.length)),s=!0}else i="",postMessage({event:"output",value:"Maximum output limit reached."}),s=!1;s&&!a?postMessage({event:"output",value:i}):a&&(i="")}if(g+=c,!g)continue;let d=g.indexOf("\n");for(d>-1?g.split("\n").forEach(e=>M("->",e)):M("->",g);d>-1;)t=g.substring(0,d),t&&(M("queued:",t),p.push(t)),g=g.substring(d+1),d=g.indexOf("\n");">"!==g&&"$"!==g&&"&"!==g||(M("queued:",g),p.push(g),g=""),r&&(l=!1),await E(2)}catch(d){postMessage({event:"logError",message:d?.message||"There were problems reading."});break}}()}(),await E(100),0!=await async function(){let e=4;for(;e>0;){await w.write(t.encode("")),M("wrote escape count: "+(4-e+1)),await E(100);let a=await h();if(M("escape result",a),a.length>=1){a=a.pop(),">"!==a&&"$"!==a||(o=a,M("mode set to",a));break}0===a.length&&await E(500),e--}if(M("synchronize : "+(4-e+1)),0===e)return await m(),0;let a=await x("");M("new line result",a),await E(500),a=await x("sel(1)"),M("sel(1) result ",a),s&&await async function(){if(!s)return;await x("echo(0)"),s=!1}();e=3;for(;e>0;){await E(100);const t=await y();if("string"==typeof t){M("version found",t),postMessage({event:"version",value:t});break}e--}return e}()){n=!0;const e=r.getInfo();postMessage({event:"connected"}),postMessage({event:"eraseall_vid_dms",value:e.usbVendorId})}else postMessage({event:"ConnectFailed",message:"Unable to detect DUELink firmware.",name:"Device is busy"})}();break;case"disconnect":m();break;case"execute":!async function(e){if(await x(">"),(e=e.toLowerCase()).startsWith("mem")){const t=await x(e);postMessage({event:"memoryRegionsResult",result:t})}else await x(e);P(`Executed: &nbsp;<code>${e}</code>`)}(R.data.line);break;case"list":!async function(e){const t=await x("list");postMessage({event:"writeResult",callbackId:e,result:t}),P("Listed program code.")}(R.data.callbackId);break;case"listAll":!async function(){const e=await x("list all");postMessage({event:"listAllResult",result:e})}();break;case"memoryRegions":b();break;case"newAll":!async function(){await x("new all"),postMessage({event:"erased"}),await b()}();break;case"play":!async function(){d=!1,postMessage({event:"playing"}),await x("run"),d||(d=!0,postMessage({event:"stopped"}))}();break;case"record":!async function(e){postMessage({event:"recording",percent:0}),await x("pgmbrst()","&"),postMessage({event:"isTalking",value:!0}),e=e.replace(/\r/gm,"").replace(/\t/gm," ").split(/\n/);let t=0;for(let a of e)await E(1),0===a.trim().length&&(a=" "),M("line",`"${a}"`),await I(a+"\n"),postMessage({event:"recording",percent:++t/e.length*100});postMessage({event:"recording",percent:100}),await I("\0"),await _(),postMessage({event:"isTalking",value:!1}),postMessage({event:"recorded"}),P("Recorded "+e.length+" line(s) of code.")}(R.data.lines);break;case"region":!async function(e){await x(`region(${e})`),postMessage({event:"regionSelected",index:e})}(R.data.index);break;case"stop":!async function(){d=!0,p.cancelWait(new Error("Stop")),w.write(t.encode("")),postMessage({event:"stopped"})}();break;case"eraseall_dms_execute_msg":!async function(){const e=r.getInfo();e.usbVendorId==v&&62209==e.usbProductId?(await w.write(new Uint8Array([250,15,199])),await E(200),postMessage({event:"eraseall_status_dms",value:2})):e.usbVendorId==v&&62208==e.usbProductId&&(await w.write(t.encode("\n")),await E(400),await w.write(t.encode("reset(1)\n")),await E(100),await w.write(t.encode("reset(1)\n")),await E(700),postMessage({event:"eraseall_status_dms",value:2}))}();break;case"eraseall_dms_connect_msg":!async function(){M(`Port status ${n}`),[r]=await navigator.serial.getPorts();try{await r.open({baudRate:115200,dataBits:8,parity:"none",stopBits:1,flowControl:"none"})}catch(t){return postMessage({event:"ConnectFailed",message:t?.message,name:t.name,full:t}),void k(t?.message||"Unable to open port.")}if(r.addEventListener("disconnect",()=>{M("Port disconnected"),m()}),null==r?.writable)return void k("Port is not a writable.");if(null==r?.readable)return void k("Port is not a readable.");const e=r.getInfo();e.usbVendorId==v&&(w=r.writable.getWriter(),postMessage({event:"eraseall_vid_dms",value:e.usbVendorId<<16|e.usbProductId}));postMessage({event:"eraseall_status_dms",value:1})}()}})}();
